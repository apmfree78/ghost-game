
// extracts winning leters , if any, from words stats
// generated by game simulation
export function getWinningLetters(stats) {

  const winningLetters = [];

  // checking if there are winning letters with NO losses
  for (const letter in stats) {
    if (stats[letter].wins > 0 && stats[letter].losses === 0) {
      winningLetters.push(letter);
    }
  }

  //if no wins and zero losses letters than check for 
  // wins > losses 
  if (winningLetters.length === 0) {

    for (const letter in stats) {
      if (stats[letter].wins >= stats[letter].losses) {
        winningLetters.push(letter);
      }
    }
  }

  // final check if there are winning letters, 
  // if so , return then, if not , return null
  if (winningLetters.length > 0) return winningLetters;
  else return null;
}

//************************************************************
//************************************************************
// MAIN GAME PLAY SIMULATION BY COMPUTER
// 'tree' is the dictionary prefix tree
//************************************************************
//************************************************************
export function mineWinningLetters(currentPrefix, tree) {

  // object to track wins and losses of each word!!!!
  const letterStats = {};
  //recursive function to SIMULATE GAME PLAY   
  // use this simulation to find optimal set of next letters
  function gameSimulation(prefix, turn = 'human') {

    if (tree.hasWord(prefix)
      && prefix.length > currentPrefix.length
      && prefix.length > 3) {
      //exit condition, checking to see who lost
      const newLetter = prefix[currentPrefix.length];
      if (turn === 'human') {
        //pc won , count letter as a win 
        if (!letterStats[newLetter]) letterStats[newLetter] = { wins: 0, losses: 0 };
        letterStats[newLetter].wins++;
      } else {
        //pc lost, count letter as a loss
        if (!letterStats[newLetter]) letterStats[newLetter] = { wins: 0, losses: 0 };
        letterStats[newLetter].losses++;
      }
    }
    else {
      // extract prefix words from prefix and start recursive calls
      const prefixLetters = getValidLetters(prefix, tree);
      // console.log(prefixLetters);
      const newTurn = turn === 'pc' ? 'human' : 'pc';

      //loop through each word
      for (const letter of prefixLetters) {
        gameSimulation(prefix + letter, newTurn);
      }
    }
  }
  // running recursive function to find winningLetters
  gameSimulation(currentPrefix);
  console.log('letter stats');
  console.log(letterStats);
  // analyze stats and get winning letters
  const winningLetters = getWinningLetters(letterStats);
  console.log(`winning letters: ${winningLetters}`);

  return winningLetters;
}

// method to return array of words with length 'length'
export const getLongestWords = (arr) => {

  const finalWords = [];
  let longest = 0;
  // find length of longest word
  for (const word of arr) {
    if (word.length > longest) longest = word.length;
  }

  //find longest words
  for (const word of arr) {
    if (word.length === longest) finalWords.push(word);
  }

  return finalWords;
}


// choose random word from array
export const chooseRandomWord = (arr) => {
  const index = Math.floor(Math.random() * arr.length);
  return arr[index];
}
// checks each letter in alphabet to find all valid next letters
// in prefix
export function getValidLetters(prefix, tree) {

  const alphabet = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "e",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
  ]
  const validLetters = [];
  // scan through alphabet and check if prefix + letter is valid
  for (const letter of alphabet) {
    if (tree.isPrefix(prefix + letter)) validLetters.push(letter);
  }
  return validLetters;
}
